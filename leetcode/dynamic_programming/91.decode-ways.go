/**
 * @Time : 2020-12-27 15:59
 * @Author : yz
 */

package dynamic_programming

import (
	"strconv"
	"strings"
)

/**
标签：字符串、动态规划
难度：中等

题目内容：
91.解码方法
一条包含字母 A-Z 的消息通过以下映射进行了编码 ：
"1" -> 'A'
"2" -> 'B'
...
"25" -> 'Y'
"26" -> 'Z'
然而，在解码已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（"2" 和 "5" 与 "25"）。
例如，"11106" 可以映射为：
"AAJF" ，将消息分组为 (1, 1, 10, 6)
"KJF" ，将消息分组为 (11, 10, 6)
消息不能分组为 (1, 11, 06)，因为 "06" 不是一个合法编码（只有 "6" 是合法的）。
注意，可能存在无法解码的字符串。
给你一个只含数字的非空字符串 s，请计算并返回解码方法的总数。如果没有合法的方式解码整个字符串，返回 0。
题目数据保证答案肯定是一个 32 位的整数。

解题思路：见代码注释及状态方程
f[i] = f[i-1] + f[i-2]  11
f[i] = f[i-1]           01 / 27
f[i] = f[i-2]           10
*/

func numDecodings(s string) int {

	if len(s) == 1 {
		// 如果字符串长度为1，且为0，则返回 0 种解码方法
		if s == "0" {
			return 0
		}
		// 如果字符串长度为1，且不为0，则返回 1 种解码方法
		return 1
	}

	length := len(s)
	f := make([]int, length)

	// --------------------------算出第一个位置存在多少种解码方式--------------------------
	// 将字符串转为字符串切片
	ss := strings.Split(s, "")
	if ss[0] != "0" {
		// 如果切片的第一个位置的值不为 0，则状态方程第一个位置的值设置为 1
		f[0] = 1
	} else {
		// 如果切片的第一个位置的值为 0，则直接返回 0 种解码方法
		return 0
	}

	// --------------------------算出第二个位置存在多少种解码方式--------------------------
	// 获得第一个和第二个字符
	sss := ss[0] + ss[1]
	temp, _ := strconv.Atoi(sss)
	if ss[1] != "0" {
		if temp <= 26 {
			// 如果第二个字符不为0，且第一个和第二个字符组合值小于等于26，则第二个位置能得到两种解码方式
			f[1] = 2
		} else {
			// 如果第二个字符不为0，且第一个和第二个字符组合值大于26，则第二个位置只能得到一种解码方式
			f[1] = 1
		}
	} else {
		if temp > 26 {
			// 如果第二个字符为0，且第一个和第二个字符组合值大于26，则是 0 种解码方式，无法解码
			return 0
		}
		// 如果第二个字符为0，且第一个和第二个字符组合值小于等于26，则是 1 种解码方式
		f[1] = f[0]
	}

	// --------------------------算出第三个位置起之后的存在多少种解码方式--------------------------
	for i := 2; i < len(s); i++ {
		// 获得当前位置及前一个位置组合的字符串
		sss := ss[i-1] + ss[i]
		temp, _ := strconv.Atoi(sss)

		if ss[i] == "0" {
			if ss[i-1] == "0" || temp > 26 {
				// 如果当前位置为 0，前一个位置也为 0 或者组合大于 26，则整个字符串判定为无法解码
				return 0
			}
			// 如果当前位置为 0，前一个位置也不为 0 且组合小于等于 26，则到这个位置，解码方式没有增加，
			// i 位置的解码方式继续延用 i-2 这个位置
			f[i] = f[i-2]

		} else if temp > 26 {
			// 如果当前位置不为 0，前一个位置和当前位置的组合大于 26，则 i 位置的解码方式继续延用 i-1 这个位置
			f[i] = f[i-1]
		} else {
			if ss[i-1] == "0" {
				// 如果当前位置不为 0，前一个位置和当前位置的组合小于等于 26，前一个位置为 0，则 i 位置的解码方式继续延用 i-1 这个位置
				f[i] = f[i-1]
			} else {
				// 如果当前位置不为 0，前一个位置和当前位置的组合小于等于 26，前一个位置不为 0，
				// 则 i 位置的解码方式为 i-1 这个位置和 i-2 这个位置之和
				f[i] = f[i-1] + f[i-2]
			}
		}
	}

	return f[length-1]
}
