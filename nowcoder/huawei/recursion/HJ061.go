package recursion

import "fmt"

/**
题目内容：
把 m 个同样的苹果放在 n 个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？
注意：如果有 7 个苹果和 3 个盘子，（5，1，1）和（1，5，1）被视为是同一种分法。
数据范围：0 ≤ m ≤ 10，1 ≤ n ≤ 10

解题思路：
以 7 个苹果和 3 个盘子为例子：
从第一个和第二个盘子为 0 开始，第一次保持 3-2=1 个盘子不动
第一个盘子保持为 0，第二个盘子从 0 开始递增，直到后面两个盘子出现了小于等于 7/2=3 的数量
0 0 7
0 1 6
0 2 5
0 3 4
第一个盘子保持为 1，第二个盘子从 1 开始递增，直到后面两个盘子出现了小于等于 7/2=3 的数量
1 1 5
1 2 4
1 3 3
第一个盘子保持为 2，第二个盘子从 2 开始递增，直到后面两个盘子出现了小于等于 7/2=3 的数量
2 2 3
-----------------------------------------------------------------------------
以 4 个苹果和 4 个盘子为例子：
从第一个、第二个、第三个盘子为 0 开始，保持 4-2=2 个盘子不动
第一个盘子保持为 0，第二个盘子保持为 0，第三个盘子从 0 开始递增，直到有两个盘子出现相等数量或相近数量的苹果
0 0 0 4
0 0 1 3
0 0 2 2
第一个盘子保持为 0，第二个盘子保持为 1，第三个盘子从 1 开始递增，直到有两个盘子出现相等数量或相近数量的苹果
0 1 1 2
第一个盘子保持为 1，第二个盘子保持为 1，第三个盘子从 1 开始递增，直到有两个盘子出现相等数量或相近数量的苹果
1 1 1 1
第一个盘子保持为 2，第二个盘子从 2 开始递增，直到任意一个盘子出现了小于等于 7/2=3 的数量

*/

func putApples() {
	a := 0
	b := 0
	for {
		n, _ := fmt.Scan(&a, &b)
		if n == 0 {
			break
		} else {
			fmt.Printf("%d\n", a+b)
		}
	}
}
